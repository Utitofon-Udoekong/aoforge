# DAO Application

Build a complete Decentralized Autonomous Organization (DAO) with voting, proposals, and member management.

## Overview

This example demonstrates how to create a full-featured DAO application using ao-forge, including:

- **Voting System** - Quadratic voting with delegation
- **Proposal Management** - Create, vote on, and execute proposals
- **Member Management** - Add/remove members and manage permissions
- **Treasury Management** - Handle DAO funds and transactions
- **Governance** - Implement governance mechanisms

## Project Setup

### Create the Project
```bash
# Create new DAO project
ao-forge init my-dao --template dao

# Or create manually
ao-forge init my-dao --framework nextjs
cd my-dao
```

### Install Dependencies
```bash
# Install additional dependencies
npm install @solana/web3.js @solana/wallet-adapter-react
npm install @headlessui/react @heroicons/react
npm install date-fns
```

## AO Process Implementation

### DAO Contract (dao.lua)
```lua
-- DAO Contract with voting and proposal management
local dao = {}

-- State management
local function getProposal(id)
    return json.decode(AO.load("proposal:" .. id) or "{}")
end

local function setProposal(id, proposal)
    AO.store("proposal:" .. id, json.encode(proposal))
end

local function getMember(address)
    return json.decode(AO.load("member:" .. address) or "{}")
end

local function setMember(address, member)
    AO.store("member:" .. address, json.encode(member))
end

-- Create proposal
Handlers.add("create_proposal", function(msg)
    local proposal = {
        id = msg.ProposalId,
        title = msg.Title,
        description = msg.Description,
        proposer = msg.From,
        created = msg.Timestamp,
        votes = {},
        status = "active",
        type = msg.Type or "governance"
    }
    
    setProposal(proposal.id, proposal)
    
    return { success = true, proposal = proposal }
end)

-- Vote on proposal
Handlers.add("vote", function(msg)
    local proposalId = msg.ProposalId
    local voter = msg.From
    local vote = msg.Vote -- "yes", "no", "abstain"
    local weight = msg.Weight or 1
    
    local proposal = getProposal(proposalId)
    if not proposal or proposal.status ~= "active" then
        return { error = "Proposal not found or not active" }
    end
    
    -- Check if member can vote
    local member = getMember(voter)
    if not member or not member.canVote then
        return { error = "Not authorized to vote" }
    end
    
    -- Record vote
    proposal.votes[voter] = {
        vote = vote,
        weight = weight,
        timestamp = msg.Timestamp
    }
    
    setProposal(proposalId, proposal)
    
    return { success = true, vote = proposal.votes[voter] }
end)

-- Execute proposal
Handlers.add("execute_proposal", function(msg)
    local proposalId = msg.ProposalId
    local proposal = getProposal(proposalId)
    
    if not proposal or proposal.status ~= "active" then
        return { error = "Proposal not found or not active" }
    end
    
    -- Calculate votes
    local yesVotes = 0
    local noVotes = 0
    local totalWeight = 0
    
    for voter, voteData in pairs(proposal.votes) do
        totalWeight = totalWeight + voteData.weight
        if voteData.vote == "yes" then
            yesVotes = yesVotes + voteData.weight
        elseif voteData.vote == "no" then
            noVotes = noVotes + voteData.weight
        end
    end
    
    -- Check if proposal passed (simple majority)
    if yesVotes > noVotes then
        proposal.status = "passed"
        -- Execute proposal logic here
        if proposal.type == "treasury" then
            -- Handle treasury transactions
        elseif proposal.type == "governance" then
            -- Handle governance changes
        end
    else
        proposal.status = "rejected"
    end
    
    setProposal(proposalId, proposal)
    
    return { 
        success = true, 
        proposal = proposal,
        results = {
            yesVotes = yesVotes,
            noVotes = noVotes,
            totalWeight = totalWeight
        }
    }
end)

-- Add member
Handlers.add("add_member", function(msg)
    local address = msg.Address
    local member = {
        address = address,
        joined = msg.Timestamp,
        canVote = true,
        canPropose = true,
        weight = 1
    }
    
    setMember(address, member)
    
    return { success = true, member = member }
end)

-- Get proposal
Handlers.add("get_proposal", function(msg)
    local proposalId = msg.ProposalId
    local proposal = getProposal(proposalId)
    
    if not proposal then
        return { error = "Proposal not found" }
    end
    
    return { success = true, proposal = proposal }
end)

-- List proposals
Handlers.add("list_proposals", function(msg)
    local proposals = {}
    local limit = msg.Limit or 10
    local offset = msg.Offset or 0
    
    -- This is a simplified implementation
    -- In practice, you'd need to maintain a list of proposal IDs
    
    return { success = true, proposals = proposals }
end)
```

## Frontend Implementation

### DAO Dashboard Component
```tsx
// components/DAODashboard.tsx
import React, { useState, useEffect } from 'react'
import { useWallet } from '@solana/wallet-adapter-react'

interface Proposal {
  id: string
  title: string
  description: string
  proposer: string
  created: number
  status: string
  votes: Record<string, any>
}

export default function DAODashboard() {
  const { publicKey, connected } = useWallet()
  const [proposals, setProposals] = useState<Proposal[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (connected) {
      loadProposals()
    }
  }, [connected])

  const loadProposals = async () => {
    try {
      // Load proposals from AO process
      const response = await fetch('/api/dao/proposals')
      const data = await response.json()
      setProposals(data.proposals || [])
    } catch (error) {
      console.error('Error loading proposals:', error)
    } finally {
      setLoading(false)
    }
  }

  const createProposal = async (title: string, description: string) => {
    if (!connected || !publicKey) return

    try {
      const response = await fetch('/api/dao/proposals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title,
          description,
          proposer: publicKey.toString()
        })
      })

      if (response.ok) {
        loadProposals()
      }
    } catch (error) {
      console.error('Error creating proposal:', error)
    }
  }

  const voteOnProposal = async (proposalId: string, vote: string) => {
    if (!connected || !publicKey) return

    try {
      const response = await fetch('/api/dao/vote', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          proposalId,
          vote,
          voter: publicKey.toString()
        })
      })

      if (response.ok) {
        loadProposals()
      }
    } catch (error) {
      console.error('Error voting:', error)
    }
  }

  if (loading) {
    return <div>Loading DAO dashboard...</div>
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-8">DAO Dashboard</h1>
      
      {/* Create Proposal Form */}
      <div className="bg-white rounded-lg shadow p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4">Create New Proposal</h2>
        <ProposalForm onSubmit={createProposal} />
      </div>

      {/* Proposals List */}
      <div className="space-y-6">
        <h2 className="text-2xl font-semibold">Active Proposals</h2>
        {proposals.map((proposal) => (
          <ProposalCard
            key={proposal.id}
            proposal={proposal}
            onVote={voteOnProposal}
            userAddress={publicKey?.toString()}
          />
        ))}
      </div>
    </div>
  )
}
```

### Proposal Card Component
```tsx
// components/ProposalCard.tsx
import React, { useState } from 'react'
import { formatDistanceToNow } from 'date-fns'

interface ProposalCardProps {
  proposal: Proposal
  onVote: (proposalId: string, vote: string) => void
  userAddress?: string
}

export default function ProposalCard({ proposal, onVote, userAddress }: ProposalCardProps) {
  const [selectedVote, setSelectedVote] = useState<string>('')

  const handleVote = () => {
    if (selectedVote && userAddress) {
      onVote(proposal.id, selectedVote)
    }
  }

  const getVoteCounts = () => {
    let yesVotes = 0
    let noVotes = 0
    let abstainVotes = 0

    Object.values(proposal.votes).forEach((vote: any) => {
      if (vote.vote === 'yes') yesVotes += vote.weight
      else if (vote.vote === 'no') noVotes += vote.weight
      else if (vote.vote === 'abstain') abstainVotes += vote.weight
    })

    return { yesVotes, noVotes, abstainVotes }
  }

  const { yesVotes, noVotes, abstainVotes } = getVoteCounts()
  const totalVotes = yesVotes + noVotes + abstainVotes

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-start mb-4">
        <h3 className="text-xl font-semibold">{proposal.title}</h3>
        <span className={`px-3 py-1 rounded-full text-sm ${
          proposal.status === 'active' ? 'bg-green-100 text-green-800' :
          proposal.status === 'passed' ? 'bg-blue-100 text-blue-800' :
          'bg-red-100 text-red-800'
        }`}>
          {proposal.status}
        </span>
      </div>

      <p className="text-gray-600 mb-4">{proposal.description}</p>

      <div className="flex justify-between items-center mb-4">
        <span className="text-sm text-gray-500">
          Proposed by {proposal.proposer.slice(0, 8)}...{proposal.proposer.slice(-8)}
        </span>
        <span className="text-sm text-gray-500">
          {formatDistanceToNow(new Date(proposal.created))} ago
        </span>
      </div>

      {/* Vote Results */}
      <div className="mb-4">
        <div className="flex justify-between text-sm mb-2">
          <span>Yes: {yesVotes}</span>
          <span>No: {noVotes}</span>
          <span>Abstain: {abstainVotes}</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div 
            className="bg-green-500 h-2 rounded-full" 
            style={{ width: `${totalVotes > 0 ? (yesVotes / totalVotes) * 100 : 0}%` }}
          ></div>
        </div>
      </div>

      {/* Voting Interface */}
      {proposal.status === 'active' && userAddress && (
        <div className="flex items-center space-x-4">
          <select
            value={selectedVote}
            onChange={(e) => setSelectedVote(e.target.value)}
            className="border rounded px-3 py-2"
          >
            <option value="">Select vote</option>
            <option value="yes">Yes</option>
            <option value="no">No</option>
            <option value="abstain">Abstain</option>
          </select>
          <button
            onClick={handleVote}
            disabled={!selectedVote}
            className="bg-blue-500 text-white px-4 py-2 rounded disabled:opacity-50"
          >
            Vote
          </button>
        </div>
      )}
    </div>
  )
}
```

## API Routes

### Proposals API
```typescript
// pages/api/dao/proposals.ts
import { NextApiRequest, NextApiResponse } from 'next'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'GET') {
    // Get all proposals
    try {
      const response = await fetch(`${process.env.AO_PROCESS_URL}/list_proposals`)
      const data = await response.json()
      res.json(data)
    } catch (error) {
      res.status(500).json({ error: 'Failed to fetch proposals' })
    }
  } else if (req.method === 'POST') {
    // Create new proposal
    try {
      const { title, description, proposer } = req.body
      
      const response = await fetch(`${process.env.AO_PROCESS_URL}/create_proposal`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ProposalId: Date.now().toString(),
          Title: title,
          Description: description,
          From: proposer,
          Timestamp: Date.now()
        })
      })
      
      const data = await response.json()
      res.json(data)
    } catch (error) {
      res.status(500).json({ error: 'Failed to create proposal' })
    }
  } else {
    res.setHeader('Allow', ['GET', 'POST'])
    res.status(405).end(`Method ${req.method} Not Allowed`)
  }
}
```

## Configuration

### ao.config.yml
```yaml
name: 'my-dao'
framework: 'nextjs'
packageManager: 'pnpm'
luaFiles: ['dao.lua']
autoStart: true
processName: 'dao-process'
ports:
  dev: 3000
  ao: 8080
```

## Deployment

### Build and Deploy
```bash
# Build the application
ao-forge build

# Deploy to Vercel
ao-forge build --deploy --platform vercel

# Deploy AO process
ao-forge process deploy --wallet ./wallet.json
```

## Features

### Voting System
- **Quadratic Voting** - Weighted voting system
- **Delegation** - Delegate voting power to others
- **Time-based** - Voting periods with deadlines
- **Transparency** - All votes are public and verifiable

### Proposal Management
- **Multiple Types** - Governance, treasury, and custom proposals
- **Rich Content** - Support for markdown descriptions
- **Status Tracking** - Active, passed, rejected, executed
- **Execution** - Automatic execution of passed proposals

### Member Management
- **Permission System** - Different roles and permissions
- **Onboarding** - Easy member addition process
- **Weight Management** - Configurable voting weights
- **Activity Tracking** - Member participation metrics

## Best Practices

1. **Security** - Implement proper access controls
2. **Transparency** - Make all governance actions public
3. **Scalability** - Design for growth and participation
4. **User Experience** - Make voting and participation easy
5. **Testing** - Thoroughly test all governance mechanisms

## Next Steps

- Explore [NFT Marketplace](/examples/nft-marketplace) example
- Learn about [DeFi Protocol](/examples/defi-protocol) implementation
- Check out [Token Contract](/examples/token-contract) example
